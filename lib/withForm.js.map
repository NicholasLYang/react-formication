{"version":3,"sources":["../src/withForm.js"],"names":["withForm","WrappedComponent","inputs","asNonPure","defaultFocusInput","Object","entries","namespace","focusOnMount","ComponentType","Component","PureComponent","InputComponentsHOC","props","validateInputs","namespaces","context","nextErrorState","ns","value","values","error","validate","keys","length","undefined","regex","errorMessage","match","onKeyPressed","event","keyCode","activeElement","document","onAction","elementId","element","R","apply","componentRef","listeners","initialState","capitalizedName","charAt","toUpperCase","substr","inputValueNs","listenerNS","target","state","revalidate","contextSupplied","assign","newErrorState","setState","nextState","addEventListener","getElementById","tabIndex","focus","removeEventListener","refs","c"],"mappings":"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","file":"withForm.js","sourcesContent":["import React, { Component, PureComponent } from 'react'\r\n\r\nfunction withForm (WrappedComponent) {\r\n    return ({ inputs }, asNonPure=false) => {\r\n\r\n        /**\r\n         * The namespace of the input which will\r\n         * contain the default input to focus on when \r\n         * wrapped component mounts (if available)\r\n         */\r\n        let defaultFocusInput = '';\r\n\r\n        for(let [namespace, { focusOnMount }] of Object.entries(inputs)) {\r\n            if(focusOnMount) {\r\n                defaultFocusInput = namespace;\r\n                break;\r\n            }\r\n        }\r\n\r\n        let ComponentType = asNonPure ? Component : PureComponent;\r\n\r\n        class InputComponentsHOC extends ComponentType {\r\n            constructor(props) {\r\n                super(props);\r\n\r\n                /** \r\n                 * Any element or React element refs are\r\n                 * to be added to this namespace for simplicity\r\n                 * and convenience with IDE\r\n                 **/\r\n                this.R = { componentRef : undefined };\r\n\r\n                this.listeners = {};\r\n\r\n                let initialState = { context : { values : {} }};\r\n\r\n                for(let namespace of Object.keys(inputs)) {\r\n                    initialState.context.values[namespace] = '';\r\n                }\r\n\r\n                for(let [namespace, { elementId, validate } ] of Object.entries(inputs)) {\r\n\r\n                    // for each input of [xxx], create a \r\n                    // change listener in the form \"onChange[Xxx]\" \r\n                    // These callbacks detect input changes, and sets \r\n                    // state[xxx] to the new input values. \r\n                    // They are made available to the HOC's wrapped\r\n                    // components via props.\r\n\r\n                    let capitalizedName = namespace.charAt(0).toUpperCase() + \r\n                                                            namespace.substr(1);\r\n\r\n                    let inputValueNs = `${namespace}InputValue`;\r\n\r\n\r\n                    let listenerNS = `onChange${capitalizedName}`;\r\n                    this.listeners[listenerNS] = (event)=> {\r\n                        let { value } = event.target;\r\n                        \r\n                        let context = { ...this.state.context };\r\n                        context.values[namespace] = value;\r\n\r\n                        context.revalidate = (namespaces) => {\r\n                            let contextSupplied = { \r\n                                ...context,\r\n                                values : Object.assign({}, \r\n                                    context.values, { [namespace] : value }\r\n                                )\r\n                            };\r\n\r\n                            let newErrorState = this.validateInputs(namespaces, contextSupplied);\r\n\r\n                            if(newErrorState) {\r\n                                this.setState(newErrorState);\r\n                            }\r\n                        };\r\n\r\n                        let nextState = { [inputValueNs] : value, context };\r\n\r\n                        let nextErrorState = this.validateInputs([namespace], context)\r\n                        if(nextErrorState) {\r\n                            nextState = Object.assign(nextState, nextErrorState);\r\n                        }\r\n\r\n                        this.setState(nextState);\r\n                    }\r\n\r\n                    // also be sure while iterating to assign a default\r\n                    // value to inputs so that they do not register as\r\n                    // \"uncontrolled\" and start to throw React warnings\r\n                    \r\n                    initialState[inputValueNs] = '';\r\n                }\r\n\r\n                this.state = initialState;\r\n            }\r\n\r\n            validateInputs = (namespaces, context) => {\r\n                let nextErrorState = {};\r\n\r\n                for(let ns of namespaces) {\r\n                    let value = context.values[ns];\r\n                    let error = this.validate(ns, value, context);\r\n                    \r\n                    nextErrorState[`${ns}InputError`] = error;\r\n                }\r\n\r\n                if(Object.keys(nextErrorState).length) {\r\n                    return nextErrorState;\r\n                } else {\r\n                    return undefined;\r\n                }\r\n            };\r\n\r\n            /**\r\n             * Returns whether or not a namespace\r\n             * is valid with a given value with\r\n             * another context.\r\n             * \r\n             * Note : we are returning rather than\r\n             * directly setting state so we can aggregate \r\n             * multiple validation checks before setting \r\n             * state here and avoid perf hits.\r\n             * \r\n             */\r\n            validate = (namespace, value, context) => {\r\n                switch(typeof inputs[namespace].validate) {\r\n                    case 'function':\r\n                        return inputs[namespace].validate({ context, value });\r\n                    case 'object':\r\n                        let { validate } = inputs[namespace];\r\n                        if(validate.regex && validate.errorMessage) {\r\n                            let { regex, errorMessage } = validate;\r\n                            return !value.match(regex) ? errorMessage : '';\r\n                        } else {\r\n                            return '';\r\n                        }\r\n                }\r\n            };\r\n\r\n            componentDidMount () {\r\n                document.addEventListener('keypress', this.onKeyPressed);\r\n\r\n                for(let [namespace, { elementId }] of Object.entries(inputs)) {   \r\n                    let element = document.getElementById(elementId);\r\n\r\n                    if(element) {\r\n                        this.R[`${namespace}Ref`] = element;\r\n\r\n                        // allows for keyboard navigation\r\n                        // (must be specified because MUI\r\n                        // lib hides input component)\r\n\r\n                        this.R[`${namespace}Ref`].tabIndex = 0;\r\n                    }\r\n                }\r\n\r\n                if(defaultFocusInput && this.R[`${defaultFocusInput}Ref`]) {\r\n                    this.R[`${defaultFocusInput}Ref`].focus();\r\n                }\r\n            }\r\n\r\n            componentWillUnmount () {\r\n                document.removeEventListener('keypress', this.onKeyPressed);\r\n\r\n                // element references should be let\r\n                // go to free up RAM\r\n\r\n                for(let [namespace, element] of Object.entries(this.R)) {\r\n                    this.R[`${namespace}Ref`] = '';\r\n                }\r\n            }\r\n\r\n            /**\r\n             * Listens for the enter key and\r\n             * if one of our inputs are focused,\r\n             * apply a supplied action (via an input.onAction callback)\r\n             * run from the wrapped component's scope\r\n             */\r\n            onKeyPressed = (event) => {\r\n                switch(event.keyCode) {\r\n        \r\n                    case 13:   // ENTER\r\n                        let activeElement = document.activeElement;\r\n\r\n                        for (const [ namespace, { onAction, elementId } ] of Object.entries(inputs)) {\r\n                            let element = this.R[`${namespace}Ref`];\r\n                            if(element == activeElement && onAction) {\r\n                                onAction.apply(this.R.componentRef, this.props);\r\n                            }\r\n                        }\r\n                }\r\n            };\r\n\r\n            render () {\r\n                let { componentRef, ...refs } = this.R; \r\n\r\n                return (\r\n                    <WrappedComponent \r\n                        ref={ c => this.R.componentRef = c }\r\n                        { ...this.props }\r\n                        { ...this.state }\r\n                        { ...this.listeners }\r\n                        { ...refs }\r\n                    />\r\n                );\r\n            }\r\n        }\r\n\r\n        return InputComponentsHOC;\r\n    };\r\n}\r\n\r\nexport default withForm"]}